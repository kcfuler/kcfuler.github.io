---
sidebar_position: 1
---

>  [为什么说 Vue 的响应式更新比 React 快？（原理深度解析）-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1612867)
>
> [浅析有react fiber为什么不需要vue fiber：理解Fiber是什么及react和vue各自响应式原理 - 古兰精 - 博客园 (cnblogs.com)](https://www.cnblogs.com/goloving/p/14793549.html)

​	之前通过《vuejs设计与实现》了解了vue3的实现原理以及它和vue2的区别，也在各个博客中了解过react的实现原理，但对它们之间的实现机制的区别一直没有一个很清晰的认知，通过这篇文章来整理一下自己的知识，也算是解答自己的疑惑。

![image-20231004133130193](https://s2.loli.net/2023/10/04/WHCah1D3Alriy9o.png)

### 问题

1. react、vue触发响应式时的渲染机制
2. vue比react快的原因
3. react的fiber机制

### react的渲染机制

#### 表现

​	父组件发生改变，递归地重新构造所有子组件（没有手动性能优化的情况下）

#### 原因

​	每一个组件在实现时都是一个对象，而子组件是组件的一个属性。细粒度的diff判断需要收集到足够的信息：你不想完全渲染整个对象，那么就需要提供不需要渲染的部分的信息。

​	React设计理念是`Immutable` ，每一次的响应式触发都返回一个**新的对象**，这样渲染机制就没法得到足够的信息，全量渲染就是必然的了

#### 改进

##### fiber

​	因为在触发渲染时，react会让父组件和它的所有子组件都重新diff渲染，导致性能问题。fiber**并没有解决渲染粒度的问题**，它起到的作用是让vdom的构建、diff过程**能够被打断**，避免单次计算耗时过长带来的卡顿

1. 实现机制

   ​	react的diff算法执行流程是**dfs**，在正常的树结构中，diff算法如果被打断，只能记录下当前节点的信息，在被打断时没有办法拿到**父组件**的信息。

   ​	在新的结构中，每个节点有三个指针，分别指向子节点、下一个兄弟节点和父节点，这个新的结构就是fiber。这样在计算被打断时，就可以通过指针的信息重建fiber树（拿到父组件的信息），继续计算。



### vue的渲染机制

#### 表现

​	在组件的响应式依赖变更时，只会触发**当前的组件**的重新渲染，不会重新递归的构造子组件（除部分场景，如slot）

#### 原因

​	vue的实现使用`proxy`代理的机制，对响应式依赖的收集粒度可以细到某一个组件（对象的每一个属性），而每一个组件都有自己的依赖收集器，有足够的信息避免重复渲染

